classdef test_SchedulerGraphWrapper < amsla.test.tools.AmslaTest
    %TEST_SCHEDULERGRAPHWRAPPER Tests for
    %amsla.common.internal.SchedulerGraphWrapper.
    
    % Copyright 2019-2020 Andrea Picciau
    %
    % Licensed under the Apache License, Version 2.0 (the "License");
    % you may not use this file except in compliance with the License.
    % You may obtain a copy of the License at
    %
    %    http://www.apache.org/licenses/LICENSE-2.0
    %
    % Unless required by applicable law or agreed to in writing, software
    % distributed under the License is distributed on an "AS IS" BASIS,
    % WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    % See the License for the specific language governing permissions and
    % limitations under the License.
    
    %% The roots by sub-graph or in the whole graph are identified correctly
    
    properties(TestParameter)
        
        GraphRootsPair = struct( ...
            'SimpleLowerTriangularNoSubGraphs', struct( ...
            'InputGraph',   	{ iSimpleLowerTriangularNoSubGraphs() }, ...
            'AllRoots',      	{ iSimpleLowerTriangularAllRoots() }, ...
            'RootsBySubGraph',	{ {} }), ...
            ...
            'SimpleLowerTriangularWithSubGraphs', struct( ...
            'InputGraph',   	{ iSimpleLowerTriangularWithSubGraphs() }, ...
            'AllRoots',      	{ iSimpleLowerTriangularAllRoots() }, ...
            'RootsBySubGraph',	{ iSimpleLowerTriangularRootsBySubGraph() }) ...
            );
        
    end
    
    methods(Test)
        
        function rootsInTheWholeGraphAreIdentifiedCorrectly(testCase, GraphRootsPair)
            % Check that the method "getRootsOfGraph" identifies the roots
            % in a graph correctly, independently of the sub-graphs having
            % been defined or not.
            
            currGraph = GraphRootsPair.InputGraph;
            expectedRoots = GraphRootsPair.AllRoots;
            
            testCase.verifyRootsIdentifiedCorrectly(currGraph, expectedRoots, ...
                'graph');
        end
        
        function rootsBySubGraphAreIdentifiedCorrectly(testCase, GraphRootsPair)
            % Check that the method "getRootsBySubGraph" identifies the roots
            % in a graph correctly, independently of the sub-graphs having
            % been defined or not.
            
            currGraph = GraphRootsPair.InputGraph;
            expectedRoots = GraphRootsPair.RootsBySubGraph;
            
            testCase.verifyRootsIdentifiedCorrectly(currGraph, expectedRoots, ...
                'sub-graph');
        end
        
    end
    
    methods(Access=private)
        
        function verifyRootsIdentifiedCorrectly(testCase, currGraph, expectedRoots, rootType)
            % Verify that the roots in the graph (either in the whole graph
            % of by sub-graph) are identified correctly by the
            % corresponding methods of SchedulerGraphWrapper.
            
            wrapperToTest = amsla.common.internal.SchedulerGraphWrapper(currGraph);
            
            if strcmp(rootType, "graph")
                methodCall = @() wrapperToTest.getRootsOfGraph();
            elseif strcmp(rootType, "sub-graph")
                methodCall = @() wrapperToTest.getRootsBySubGraph();
            else
                error("amsla:test:badRootType", ...
                    "Invalid type of root node.");
            end
            
            actualRoots = testCase.verifyWarningFree(methodCall, ...
                "An error or warning was thrown while identifying the roots by " + ...
                rootType);
            testCase.verifyEqual(actualRoots, expectedRoots, ...
                "The expected and actual roots do not match");
        end
        
    end
    
    %% Looping edges are identified correctly
    
    methods(Test)
        function loopingEdgesInSimpleGraphAreIdentifiedCorrectly(testCase)
            % Check that the method 'getLoopingEdges' identifies
            % the looping edges (i-->i and weight==1) correctly.
            
            aGraph = iSimpleLowerTriangularNoSubGraphs();
            wrapperToTest = amsla.common.internal.SchedulerGraphWrapper(aGraph);
            actualLoopingEdges = wrapperToTest.getLoopingEdges(aGraph.listOfNodes());
            
            expectedLoopingEdges = [1, 6, 8, 13, 18];
            testCase.verifyEqual(actualLoopingEdges, expectedLoopingEdges, ...
                "Looping edges were not identified correctly.");
        end
    end
    
    %% Children with specific properties of given nodes are identified correctly
    
    properties(TestParameter)
        
        NodeAndReadyChildrenPairNotConsideringSubGraphs = setstructfields( ...
            iBaseCasesReadyChildren(), ...
            iCornerCasesReadyChildrenNoSubGraphs());
        
        NodeAndReadyChildrenPairBySubGraph = setstructfields( ...
            iBaseCasesReadyChildren(), ...
            iCornerCasesReadyChildrenWithSubGraphs());
        
        GraphWithEdgesAssigned = struct( ...
            'SimpleLowerTriangularNoSubGraphs',     { iSimpleLowerTriangularNoSubGraphs() }, ...
            'SimpleLowerTriangularWithSubGraphs',   { iSimpleLowerTriangularWithSubGraphs() });
        
    end
    
    methods(Test)
        
        function identifiesChildrenReadyForProcessingNotConsideringSubGraphs(testCase, ...
                GraphWithEdgesAssigned, ...
                NodeAndReadyChildrenPairNotConsideringSubGraphs)
            % Check that the method 'getReadyChildrenOfNode' identifies
            % correctly the children of a given node that are ready to be
            % processed.
            
            testCase.verifyChildrenMatchExpected( ...
                GraphWithEdgesAssigned, ...
                NodeAndReadyChildrenPairNotConsideringSubGraphs, ...
                @getReadyChildrenOfNode);
        end
        
        function identifiesChildrenReadyForProcessingWithSubGraphs(testCase, ...
                NodeAndReadyChildrenPairBySubGraph)
            % Check that the method 'getReadyChildrenOfNode' identifies
            % correctly the children of a given node that are ready to be
            % processed.
            
            testCase.verifyChildrenMatchExpected( ...
                iSimpleLowerTriangularWithSubGraphs(), ...
                NodeAndReadyChildrenPairBySubGraph, ...
                @getReadyChildrenOfNodeBySubGraph);
        end
        
    end
    
    methods(Access=private)
        
        function verifyChildrenMatchExpected(testCase, ...
                inputGraph, specStruct, childrenSelection)
            % Common logic for the test methods that verify children being
            % identified correctly.
            
            actualChildren = ...
                iObtainChildren(inputGraph, ...
                childrenSelection, ...
                specStruct.ProcessedNodes, ...
                specStruct.ParentNodes);
            expectedChildren = specStruct.ExpectedChildren;
            
            if isempty(expectedChildren)
                % Special case: ignore different types of "empty".
                testCase.verifyEmpty(expectedChildren, ...
                    "The set of children was expected to be empty");
            else
                testCase.verifyEqual(actualChildren, expectedChildren, ...
                    "Children weren't identified correctly.");
            end
        end
        
    end
    
end

%% HELPER FUNCTIONS

function actualChildren = iObtainChildren(currGraph, method, processedNodes, parentNodes)
wrapperToTest = amsla.common.internal.SchedulerGraphWrapper(currGraph);
wrapperToTest.markNodeAsProcessed(processedNodes);
actualChildren = method(wrapperToTest, parentNodes);
end

function aGraph = iSimpleLowerTriangularNoSubGraphs()
assignmentTable = array2table([ ...
    [[ 1,  1], -1,  1, NaN]; ...
    [[ 2,  1],  1,  2, 1]; ...
    [[ 2,  2],  1,  3, NaN]; ...
    [[ 3,  1],  1,  4, 1]; ...
    [[ 3,  3],  1,  5, NaN]; ...
    [[ 4,  4],  3,  6, NaN]; ...
    [[ 5,  4],  1,  7, 1]; ...
    [[ 5,  5],  3,  8, NaN]; ...
    [[ 6,  3],  1,  9, 2]; ...
    [[ 6,  5],  1, 10, 2]; ...
    [[ 6,  6],  1, 11, NaN]; ...
    [[ 7,  6],  1, 12, 3]; ...
    [[ 7,  7],  4, 13, NaN]; ...
    [[ 8,  6],  1, 14, 3]; ...
    [[ 8,  8],  1, 15, NaN]; ...
    [[ 9,  9],  1, 16, NaN]; ...
    [[10,  9],  1, 17, NaN]; ...
    [[10, 10], 10, 18, 5]], ...
    'VariableNames', ["I", "J", "V", "EdgeId", "TimeSlotId"]);
aGraph = amsla.common.DataStructure( ...
    assignmentTable.I, ...
    assignmentTable.J, ...
    assignmentTable.V);
for k = 1:numel(assignmentTable.EdgeId)
    currEdgeId = assignmentTable.EdgeId(k);
    aGraph.setTimeSlotOfEdge(currEdgeId, assignmentTable.TimeSlotId(k));
end
end

function aGraph = iSimpleLowerTriangularWithSubGraphs()
aGraph = iSimpleLowerTriangularNoSubGraphs();
aGraph.setSubGraphOfNode( ...
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], ...
    [1, 1, 1, 2, 2, 3, 3, 3, 4, 4]);
end

function roots = iSimpleLowerTriangularAllRoots()
roots = [1, 4, 9];
end

function roots = iSimpleLowerTriangularRootsBySubGraph()
roots = {1, 4, 6, 9};
end

function outStruct = iBaseCasesReadyChildren()
outStruct = struct( ...
    'Node1', struct( ...
    'ParentNodes',   	{ 1 }, ...
    'ProcessedNodes',   { 1 }, ...
    'ExpectedChildren',	{ [2, 3] }), ...
    ...
    'Node4', struct( ...
    'ParentNodes',      { 4 }, ...
    'ProcessedNodes',   { 4 }, ...
    'ExpectedChildren', { 5 }), ...
    ...
    'Node6', struct( ...
    'ParentNodes',      { 6 }, ...
    'ProcessedNodes',   { 6 }, ...
    'ExpectedChildren', { [7, 8] }), ...
    ...
    'Node9NotProcessed', struct( ...
    'ParentNodes',      { 9 }, ...
    'ProcessedNodes',   { [] }, ...
    'ExpectedChildren', { [] }), ...
    ...
    'Nodes4and6', struct( ...
    'ParentNodes',      { [4, 6] }, ...
    'ProcessedNodes',   { [4, 6] }, ...
    'ExpectedChildren', { [5, 7, 8] }));
end

function outStruct = iCornerCasesReadyChildrenNoSubGraphs()
outStruct = struct( ...
    'Node3', struct( ...
    'ParentNodes',      { 3 }, ...
    'ProcessedNodes',   { [3, 5] }, ...
    'ExpectedChildren', { 6 }), ...
    ...
    'Nodes3and9', struct( ...
    'ParentNodes',      { [3, 9] }, ...
    'ProcessedNodes',   { [3, 5, 9] }, ...
    'ExpectedChildren', { [6, 10] }), ...
    ...
    'Nodes3and6', struct( ...
    'ParentNodes',      { [3, 6] }, ...
    'ProcessedNodes',   { [3, 5, 6] }, ...
    'ExpectedChildren', { [6, 7, 8] }));
end

function outStruct = iCornerCasesReadyChildrenWithSubGraphs()
outStruct = struct( ...
    'Node3', struct( ...
    'ParentNodes',      { 3 }, ...
    'ProcessedNodes',   { [3, 5] }, ...
    'ExpectedChildren', { [] }), ...
    ...
    'Nodes3and9', struct( ...
    'ParentNodes',       { [3, 9] }, ...
    'ProcessedNodes',    { [3, 5, 9] }, ...
    'ExpectedChildren',  { 10 }), ...
    ...
    'Nodes3and6', struct( ...
    'ParentNodes',       { [3, 6] }, ...
    'ProcessedNodes',    { [3, 6] }, ...
    'ExpectedChildren',  { [7, 8] }));
end